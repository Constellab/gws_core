import atexit
import contextlib
import os
from typing import Optional

from gws_core.apps.app_nginx_service import AppNginxServiceInfo
from gws_core.core.classes.observer.message_observer import LoggerMessageObserver
from gws_core.core.utils.logger import Logger
from gws_core.core.utils.settings import Settings
from gws_core.impl.file.file_helper import FileHelper
from gws_core.impl.shell.shell_proxy import ShellProxy


class AppNginxManager:
    """Singleton to manage the nginx service to run apps.
    It handles the registration of services, generation of nginx configuration,
    and starting/stopping the nginx server.
    """

    _instance: Optional["AppNginxManager"] = None
    _services: dict[str, AppNginxServiceInfo]

    _NGINX_CONF_FILENAME = "nginx.conf"

    NGINX_TEMPLATE = """
# Nginx configuration template for apps
# This file is automatically generated by NginxManager

events {
    worker_connections 1024;
}

# PID file in a location writable by non-root user
pid [NGINX_CONFIG_DIR]/nginx.pid;

# Error log
error_log [NGINX_CONFIG_DIR]/error.log;

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # config for logging
    access_log [NGINX_CONFIG_DIR]/access.log;

    # Allow large file uploads (e.g., for data files, archives)
    client_max_body_size 10G;

    # Temp paths writable by non-root user
    client_body_temp_path [TMP_DIR]/client_body;
    proxy_temp_path [TMP_DIR]/proxy;
    fastcgi_temp_path [TMP_DIR]/fastcgi;
    uwsgi_temp_path [TMP_DIR]/uwsgi;
    scgi_temp_path [TMP_DIR]/scgi;

    # Fix for long server names
    server_names_hash_bucket_size 128;

    # Default server block to handle unmatched requests
    server {
		listen [APP_EXTERNAL_PORT] default_server;
		server_name _;
		return 444;  # Close connection without response
	}

    # This will be replaced with the actual server blocks
    [SERVERS]

}
"""

    def __init__(self):
        self._services = {}

    @classmethod
    def get_instance(cls) -> "AppNginxManager":
        """Get the global nginx manager instance"""
        if not cls._instance:
            cls._instance = cls()
        return cls._instance

    @classmethod
    def init(cls) -> None:
        """Initialize the NginxManager instance"""
        nginx_manager = cls.get_instance()
        if nginx_manager.nginx_is_running():
            Logger.info("Nginx is running, stopping it.")
            nginx_manager.stop()

    def register_services(self, services: list[AppNginxServiceInfo]) -> None:
        """Register a service and update nginx configuration"""
        for service in services:
            self._services[service.service_id] = service
            Logger.debug(
                f"Registered service: {service.service_id}, server name {service.server_name}"
            )

        self.start_or_reload()

    def unregister_services(self, service_ids: list[str]) -> None:
        """Unregister a service and update nginx configuration"""
        for service_id in service_ids:
            if service_id in self._services:
                del self._services[service_id]
                Logger.debug(f"Unregistered service: {service_id}")

        if self._services:
            self.start_or_reload()
        else:
            # if no services left, stop nginx
            self.stop()

    def get_services(self) -> list[AppNginxServiceInfo]:
        """Get all registered services"""
        return list(self._services.values())

    def get_service(self, name: str) -> AppNginxServiceInfo | None:
        """Get a specific service by name"""
        return self._services.get(name)

    def start_or_reload(self):
        """Start nginx if not already started"""
        if not self._services:
            self.stop()

        # Generate initial empty config
        self._generate_nginx_config()

        if self.nginx_is_running():
            Logger.debug("Nginx already started, reloading configuration")
            self._reload_nginx()
            return True

        # Start nginx
        self._start_nginx()
        atexit.register(self.stop)

    def stop(self, force: bool = False) -> None:
        """Stop nginx"""
        if not force and not self.nginx_is_running():
            return

        result = self._run_nginx_command(["-s", "stop"])
        if result == 0:
            Logger.info("Nginx stopped successfully")
        else:
            Logger.error("Failed to stop nginx")

    def nginx_is_running(self) -> bool:
        """Check if nginx is running"""
        pid_file = os.path.join(self.get_nginx_config_dir(), "nginx.pid")

        # Check if PID file exists
        if not os.path.exists(pid_file):
            return False

        try:
            # Read PID from file
            with open(pid_file) as f:
                pid = int(f.read().strip())

            # Check if process with this PID exists
            os.kill(pid, 0)  # Signal 0 doesn't kill, just checks existence

            # Verify it's actually our nginx by checking the config in cmdline
            cmdline_file = f"/proc/{pid}/cmdline"
            if os.path.exists(cmdline_file):
                with open(cmdline_file, "rb") as f:
                    cmdline = f.read().decode("utf-8", errors="ignore")
                    if self.get_nginx_config_file_path() in cmdline:
                        return True
                    else:
                        Logger.info("Nginx PID exists but not using correct config")
                        self.stop(force=True)
                        return False

            return True

        except (FileNotFoundError, ValueError, ProcessLookupError, PermissionError, OSError):
            # PID file exists but process doesn't - clean up stale PID file
            if os.path.exists(pid_file):
                with contextlib.suppress(OSError):
                    os.remove(pid_file)
            return False

    def _generate_nginx_config(self):
        """Generate nginx configuration for all services"""
        config_content = self._build_nginx_config()
        config_path = self.get_nginx_config_file_path()

        try:
            with open(config_path, "w", encoding="utf-8") as f:
                f.write(config_content)
            Logger.info(f"Generated nginx config: {config_path}")

        except Exception as e:
            raise Exception(f"Failed to write nginx config to {config_path}: {e}")

    def _reload_nginx(self):
        """Reload nginx configuration"""
        # nginx is running, reload it
        result = self._run_nginx_command(["-s", "reload"])
        if result == 0:
            Logger.debug("Nginx configuration reloaded successfully")
        else:
            Logger.error("Failed to reload nginx configuration")

    def _start_nginx(self):
        """Start nginx daemon"""
        # Test configuration first
        test_result = self._run_nginx_command(["-t"])
        if test_result != 0:
            raise Exception("Nginx configuration test failed")

        # Start nginx
        result = self._run_nginx_command([])
        if result != 0:
            raise Exception("Failed to start nginx")

        Logger.info("Nginx started successfully")

    def _build_nginx_config(self) -> str:
        """Build nginx configuration content"""
        if not self._services:
            return "# No services registered\n"

        config_lines = []

        for service in self._services.values():
            server_block = service.get_nginx_service_config()
            config_lines.append(server_block)

        server = "\n".join(config_lines)
        # return the complete nginx configuration with the server blocks
        # with indentation for readability
        indented_server = "\n".join(f"\t{line}" for line in server.splitlines())

        # create the nginx config folder and tmp folder if not exists
        nginx_config_folder = self.get_nginx_config_dir()
        FileHelper.create_dir_if_not_exist(nginx_config_folder)

        nginx_tmp_folder = self.get_nginx_tmp_dir()
        FileHelper.create_dir_if_not_exist(nginx_tmp_folder)

        nginx_config = self.NGINX_TEMPLATE.replace("[SERVERS]", indented_server)
        nginx_config = nginx_config.replace("[NGINX_CONFIG_DIR]", nginx_config_folder)
        nginx_config = nginx_config.replace("[TMP_DIR]", nginx_tmp_folder)
        nginx_config = nginx_config.replace(
            "[APP_EXTERNAL_PORT]", str(Settings.get_app_external_port())
        )
        return nginx_config

    def get_nginx_config_file_path(self) -> str:
        """Get the path to the generated nginx config file"""
        return os.path.join(self.get_nginx_config_dir(), self._NGINX_CONF_FILENAME)

    def _get_shell_proxy(self) -> ShellProxy:
        """Get the ShellProxy instance for this manager"""
        shell_proxy = ShellProxy(self.get_nginx_config_dir())
        shell_proxy.attach_observer(LoggerMessageObserver())
        return shell_proxy

    def _run_nginx_command(self, args: list[str]) -> int:
        """Run nginx command with -c option always set

        Args:
            args: List of nginx arguments (e.g., ['-s', 'reload'])

        Returns:
            Exit code from the command
        """
        shell_proxy = self._get_shell_proxy()
        command = ["nginx", "-c", self.get_nginx_config_file_path()] + args
        return shell_proxy.run(command)

    def get_nginx_access_log_path(self) -> str:
        """Get the path to the nginx access log file"""
        return os.path.join(self.get_nginx_config_dir(), "access.log")

    def get_nginx_error_log_path(self) -> str:
        """Get the path to the nginx error log file"""
        return os.path.join(self.get_nginx_config_dir(), "error.log")

    def get_nginx_config_dir(self) -> str:
        """Get the nginx config directory"""
        return os.path.join(Settings.get_system_folder(), "nginx")

    def get_nginx_tmp_dir(self) -> str:
        """Get the nginx temp directory"""
        return os.path.join("/tmp", "nginx")
