# LICENSE
# This software is the exclusive property of Gencovery SAS.
# The use and distribution of this software is prohibited without the prior consent of Gencovery SAS.
# About us: https://gencovery.com

from __future__ import annotations

import copy
from enum import Enum
from typing import (TYPE_CHECKING, Any, Dict, Generic, Optional, Type, TypeVar,
                    final)

from peewee import (CharField, DeferredForeignKey, ForeignKeyField,
                    ModelDelete, ModelSelect)

from ..core.classes.enum_field import EnumField
from ..core.decorator.transaction import transaction
from ..core.exception.exceptions.bad_request_exception import \
    BadRequestException
from ..core.model.model_with_user import ModelWithUser
from ..core.utils.logger import Logger
from ..core.utils.reflector_helper import ReflectorHelper
from ..impl.file.file_r_field import FileRField
from ..impl.file.fs_node import FSNode
from ..impl.file.fs_node_model import FSNodeModel
from ..impl.file.local_file_store import LocalFileStore
from ..model.typing import Typing
from ..model.typing_manager import TypingManager
from ..model.typing_register_decorator import typing_registrator
from ..resource.kv_store import KVStore
from ..resource.r_field import BaseRField
from ..resource.resource import Resource
from ..tag.taggable_model import TaggableModel
from ..task.converter.exporter import get_resource_type_export_meta_data

if TYPE_CHECKING:
    from ..experiment.experiment import Experiment
    from ..task.task_model import TaskModel

# Typing names generated for the class Resource
CONST_RESOURCE_MODEL_TYPING_NAME = "MODEL.gws_core.ResourceModel"

ResourceType = TypeVar('ResourceType', bound=Resource)


class ResourceOrigin(Enum):
    # If the resource was imported manually by the user
    IMPORTED = "IMPORTED"
    # Generated by a task
    GENERATED = "GENERATED"


# Use the typing decorator to avoid circular dependency
@typing_registrator(unique_name="ResourceModel", object_type="MODEL", hide=True)
class ResourceModel(ModelWithUser, TaggableModel, Generic[ResourceType]):

    """
    ResourceModel class.
    """

    # typing name of the resource
    resource_typing_name = CharField(null=False)

    # Path to the kv store if the kv exists for this resource model
    kv_store_path = CharField(null=True)

    origin: ResourceOrigin = EnumField(choices=ResourceOrigin, default=ResourceOrigin.GENERATED)

    experiment: Experiment = DeferredForeignKey('Experiment', null=True, index=True)
    task_model: TaskModel = DeferredForeignKey('TaskModel', null=True, index=True)

    name: str = CharField(null=False)

    fs_node_model: FSNodeModel = ForeignKeyField(FSNodeModel, null=True, index=True, backref="+")

    _table_name = 'gws_resource'
    _resource: ResourceType = None

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        # check that the class level property _typing_name is set
        if self._typing_name == CONST_RESOURCE_MODEL_TYPING_NAME and type(self) != ResourceModel:  # pylint: disable=unidiomatic-typecheck
            raise BadRequestException(
                f"The resource model {self.full_classname()} is not decorated with @TypingDecorator, it can't be instantiate. Please decorate the class with @TypingDecorator")

    ########################################## MODEL METHODS ######################################

    @transaction()
    def delete_instance(self, *args, **kwargs):
        kv_store: Optional[KVStore] = self.get_kv_store()
        if kv_store:
            kv_store.remove()

        result = super().delete_instance(*args, **kwargs)
        if self.fs_node_model:
            self.fs_node_model.delete_instance()

        return result

    @classmethod
    def drop_table(cls, *args, **kwargs):
        """
        Drop model table
        """

        if not cls.table_exists():
            return

        super().drop_table(*args, **kwargs)

    @classmethod
    def select_by_resource_typing_name(cls, resource_typing_name: str) -> ModelSelect:
        return cls.select_me().where(cls.resource_typing_name == resource_typing_name)

    @transaction()
    def save_full(self) -> 'ResourceModel':
        """Save the resource and the fs_node if exists

        :return: [description]
        :rtype: [type]
        """
        if self.fs_node_model:
            self.fs_node_model.save()
        self.save()

        return self

    # @classmethod
    # def create_table(cls, *args, **kwargs):
    #     if cls.table_exists():
    #         return
    #     super().create_table(*args, **kwargs)
    #     # Create the foreign-key constraint:

        # if cls.get_db_manager().is_mysql_engine():
        #     cls.get_db_manager().db.execute_sql(
        #         f"CREATE FULLTEXT INDEX TAG_INDEX ON {cls.get_table_name()}(tags)")

    @classmethod
    def create_foreign_keys(cls) -> None:
        """Create the foreign keys because it was deffered
        """
        cls.create_foreign_key_if_not_exist(ResourceModel.experiment)
        cls.create_foreign_key_if_not_exist(ResourceModel.task_model)

    @classmethod
    def get_by_experiment(cls, experiment_id: str) -> ModelSelect:
        return ResourceModel.select().where(ResourceModel.experiment == experiment_id)

    @classmethod
    def delete_list(cls, resource_model_ids: str) -> ModelDelete:
        return ResourceModel.delete().where(ResourceModel.id.in_(resource_model_ids))

    ########################################## RESOURCE ######################################

    @property
    def typing_name(self) -> str:
        return self._typing_name

    @final
    def get_resource(self, new_instance: bool = False) -> ResourceType:
        """
        Returns the resource created from the data and resource_typing_name
        if new_instance, it forces to rebuild the resource
        """

        if new_instance:
            return self._instantiate_resource()

        if self._resource is None:
            self._resource = self._instantiate_resource()

        return self._resource

    def _instantiate_resource(self) -> ResourceType:
        """
        Create the Resource object from the resource_typing_name
        """
        resource_type: Type[ResourceType] = self.get_resource_type()
        resource: ResourceType = resource_type()
        # Pass the model id to the resource
        resource._model_id = self.id

        self.send_fields_to_resource(resource)
        return resource

    @classmethod
    def from_resource(cls, resource: ResourceType, origin: ResourceOrigin = ResourceOrigin.GENERATED,
                      experiment: Experiment = None, task_model: TaskModel = None) -> ResourceModel:
        """Create a new ResourceModel from a resource

        Don't set the resource here so it is regenerate on next get (avoid using same instance)

        :return: [description]
        :rtype: [type]
        """

        # If the origin is generated, then the experiment and the task must be provided
        if origin == ResourceOrigin.GENERATED and (experiment is None or task_model is None):
            raise Exception("To create a GENERATED, you must provide the experiment and the task")

        resource_model: ResourceModel = ResourceModel()
        resource_model.resource_typing_name = resource._typing_name
        resource_model.origin = origin
        resource_model.experiment = experiment
        resource_model.task_model = task_model

        if isinstance(resource, FSNode):
            # Move the node to the LocalFileStore and create fs node model
            node: FSNode = LocalFileStore.get_default_instance().add_node(resource, resource.get_name())
            fs_node_model: FSNodeModel = FSNodeModel()
            fs_node_model.path = node.path
            fs_node_model.file_store_id = node.file_store_id
            fs_node_model.size = node.get_size()
            resource_model.fs_node_model = fs_node_model
            resource = node

        # synchronize the model fields with the resource fields
        resource_model.receive_fields_from_resource(resource)

        # set the tag name if the name exist
        name: str = None
        try:
            name = resource.get_name()
        except Exception as err:
            Logger.error(f'Error while getting the name of the resource {type(resource)}. Err : {str(err)}')
            Logger.log_exception_stack_trace(err)
        if name:
            resource_model.name = name
        else:
            resource_model.name = resource._human_name

        return resource_model

    @classmethod
    def save_from_resource(cls, resource: ResourceType, origin: ResourceOrigin = ResourceOrigin.GENERATED,
                           experiment: Experiment = None, task_model: TaskModel = None) -> ResourceModel:
        """Create the ResourceModel from the Resource and save it
        """
        return cls.from_resource(resource, origin=origin, experiment=experiment, task_model=task_model).save_full()

    def send_fields_to_resource(self, resource: ResourceType):
        """for each BaseRField of the resource, set the value form the data or kvstore

        :param resource: [description]
        :type resource: ResourceType
        """
        properties: Dict[str, BaseRField] = self._get_resource_r_fields(type(resource))

        kv_store: KVStore = self.get_kv_store()

        # for each BaseRField of the resource, set the value form the data or kvstore
        for key, r_field in properties.items():

            loaded_value: Any = None
            # If the property is searchable, it is stored in the DB
            if r_field.searchable:
                loaded_value = copy.deepcopy(r_field.deserialize(self.data.get(key)))

            elif kv_store is not None:
                loaded_value = r_field.deserialize(kv_store.get(key))

            setattr(resource, key, loaded_value)

    def receive_fields_from_resource(self, resource: ResourceType):
        """for each BaseRField of the resource, store its value to the data or kvstore

        :param resource: [description]
        :type resource: ResourceType
        """
        self.data = {}
        # init the kvstore, the directory is not created until we write on the kvstore
        kv_store: KVStore = self._get_or_create_kv_store()

        # get the r_fields of the resource
        r_fields: Dict[str, BaseRField] = self._get_resource_r_fields(type(resource))

        for key, r_field in r_fields.items():
            # get the attribute value corresponding to the r_field
            r_field_value: Any = getattr(resource, key)

            # specific case for the FileRField
            if isinstance(r_field, FileRField):
                # generate a new file path inside the kv store directory
                file_path = kv_store.generate_new_file()

                # dump the resource value into the file
                r_field.dump_to_file(r_field_value, str(file_path))
                # store the file path in the kv_store
                kv_store[key] = file_path
                continue

            value: Any = r_field.serialize(r_field_value)
            # If the property is searchable, store it in the DB
            if r_field.searchable:
                self.data[key] = value

            # Otherwise, store it in the kvstore
            else:
                kv_store[key] = value

    def _get_resource_r_fields(self, resource_type: Type[ResourceType]) -> Dict[str, BaseRField]:
        """Get the list of resource's r_fields,
        the key is the property name, the value is the BaseRField object
        """
        return ReflectorHelper.get_property_names_of_type(resource_type, BaseRField)

    def get_resource_type(self) -> Type[ResourceType]:
        return TypingManager.get_type_from_name(self.resource_typing_name)

    ########################################## KV STORE ######################################

    @final
    def get_kv_store(self) -> Optional[KVStore]:
        if not self.kv_store_path:
            return None

        # Create the KVStore from the path
        kv_store: KVStore = KVStore(self.kv_store_path)

        # Lock the kvstore so the file can't be updated
        kv_store.lock(KVStore.get_full_file_path(file_name=self.id, with_extension=False))
        return kv_store

    def _get_or_create_kv_store(self) -> KVStore:
        """Get the KVStore and create an empty one if it doesn't exist

        :return: [description]
        :rtype: KVStore
        """
        kv_store: Optional[KVStore] = self.get_kv_store()
        if kv_store:
            return kv_store

        # Create the KV store
        kv_store = KVStore.from_filename(self.id)

        self.kv_store_path = kv_store.get_full_path_without_extension()
        return kv_store

    ########################################## JSON ######################################

    def to_json(self, deep: bool = False, **kwargs) -> dict:
        """
        Returns JSON string or dictionnary representation of the model.

        :param stringify: If True, returns a JSON string. Returns a python dictionary otherwise. Defaults to False
        :type stringify: bool
        :param prettify: If True, indent the JSON string. Defaults to False.
        :type prettify: bool
        :return: The representation
        :rtype: dict, str
        """

        _json = super().to_json(deep=deep, **kwargs)

        _json["typing_name"] = self._typing_name
        _json["tags"] = self.get_tags_json()

        resource_typing: Typing = TypingManager.get_typing_from_name(self.resource_typing_name)
        _json["resource_type_human_name"] = resource_typing.human_name
        _json["resource_type_short_description"] = resource_typing.short_description
        _json["resource_type"] = resource_typing.object_sub_type

        # the resource is downloadable if it's a file or if the export_to_path is defined
        _json["is_downloadable"] = self.fs_node_model or get_resource_type_export_meta_data(resource_typing.get_type())

        if self.fs_node_model:
            _json["fs_node"] = self.fs_node_model.to_json()

        return _json

    def data_to_json(self, deep: bool = False, **kwargs) -> dict:
        """
        Returns a JSON string or dictionnary representation of the model data.
        :return: The representation
        :rtype: `dict`
        """
        return {}
