# LICENSE
# This software is the exclusive property of Gencovery SAS.
# The use and distribution of this software is prohibited without the prior consent of Gencovery SAS.
# About us: https://gencovery.com

from __future__ import annotations

from enum import Enum
from typing import TYPE_CHECKING, Any, Dict, List, Optional, Set, Type, final

from peewee import (BooleanField, CharField, DeferredForeignKey, Expression,
                    ForeignKeyField, ModelDelete, ModelSelect)

from gws_core.core.utils.utils import Utils
from gws_core.experiment.experiment_exception import \
    ResourceUsedInAnotherExperimentException
from gws_core.impl.file.file_helper import FileHelper
from gws_core.model.typing_dict import TypingStatus
from gws_core.project.model_with_project import ModelWithProject
from gws_core.project.project import Project
from gws_core.resource.resource_set.resource_list_base import ResourceListBase
from gws_core.resource.technical_info import TechnicalInfoDict
from gws_core.tag.entity_tag import EntityTagType
from gws_core.tag.entity_tag_list import EntityTagList
from gws_core.tag.tag_list import TagList
from gws_core.user.current_user_service import CurrentUserService

from ..core.classes.enum_field import EnumField
from ..core.decorator.transaction import transaction
from ..core.exception.exceptions.bad_request_exception import \
    BadRequestException
from ..core.model.model_with_user import ModelWithUser
from ..core.utils.logger import Logger
from ..core.utils.reflector_helper import ReflectorHelper
from ..experiment.experiment_enums import ExperimentType
from ..impl.file.file_r_field import FileRField
from ..impl.file.fs_node import FSNode
from ..impl.file.fs_node_model import FSNodeModel
from ..impl.file.local_file_store import LocalFileStore
from ..model.typing import Typing
from ..model.typing_manager import TypingManager
from ..resource.kv_store import KVStore
from ..resource.resource import Resource
from ..tag.taggable_model import TaggableModel
from .r_field.r_field import BaseRField
from .resource_factory import ResourceFactory

if TYPE_CHECKING:
    from ..experiment.experiment import Experiment
    from ..task.task_model import TaskModel

# Typing names generated for the class Resource
CONST_RESOURCE_MODEL_TYPING_NAME = "MODEL.gws_core.ResourceModel"


class ResourceOrigin(Enum):
    # If the resource was imported manually by the user
    UPLOADED = "UPLOADED"
    # Generated by a importer
    IMPORTED = "IMPORTED"
    # Generated by a transformer
    TRANSFORMED = "TRANSFORMED"
    # Generated by a task
    GENERATED = "GENERATED"
    # Specific type for the ActionManager
    ACTIONS = "ACTIONS"
    # If the resource was imported manually by the user from another lab
    IMPORTED_FROM_LAB = "IMPORTED_FROM_LAB"
    # For project DOCUMENT where this lab work as a S3 server
    S3_PROJECT_STORAGE = "S3_PROJECT_STORAGE"


# Use the typing decorator to avoid circular dependency
class ResourceModel(ModelWithUser, TaggableModel, ModelWithProject):

    """
    ResourceModel class.
    """

    # typing name of the resource
    resource_typing_name = CharField(null=False)

    # Path to the kv store if the kv exists for this resource model
    kv_store_path = CharField(null=True)

    origin: ResourceOrigin = EnumField(
        choices=ResourceOrigin, default=ResourceOrigin.GENERATED)

    experiment: Experiment = DeferredForeignKey(
        'Experiment', null=True, index=True)
    project: Project = ForeignKeyField(Project, null=True, index=True)
    task_model: TaskModel = DeferredForeignKey(
        'TaskModel', null=True, index=True)

    # for children resource (usually resource inside ResourceSet), it stores the parent resource id
    # lazy_load = False to avoir loading the resource, and it only contains the id
    parent_resource_id: str = ForeignKeyField(
        'self', null=True, index=True, lazy_load=False)

    name: str = CharField(null=False)

    fs_node_model: FSNodeModel = ForeignKeyField(
        FSNodeModel, null=True, index=True, backref="+")

    # true when the resource is UPLOADED or is an experiment output
    flagged: bool = BooleanField(default=False)

    # provided when the resource is generated by an experiment, this contains the port name of the task that generated it
    generated_by_port_name: str = CharField(null=True)

    brick_version = CharField(null=False, max_length=50, default="")

    _table_name = 'gws_resource'
    _resource: Resource = None

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        # check that the class level property _typing_name is set
        if self._typing_name == CONST_RESOURCE_MODEL_TYPING_NAME and type(self) != ResourceModel:  # pylint: disable=unidiomatic-typecheck
            raise BadRequestException(
                f"The resource model {self.full_classname()} is not decorated with @TypingDecorator, it can't be instantiate. Please decorate the class with @TypingDecorator")

    ########################################## MODEL METHODS ######################################

    @transaction()
    def delete_instance(self, *args, **kwargs):
        result = super().delete_instance(*args, **kwargs)
        if self.fs_node_model:
            self.fs_node_model.delete_instance(delete_file=False)

        self._delete_object()

        return result

    @classmethod
    def delete_multiple_resources(cls, resources: List[ResourceModel]):
        # sort the resources to have children resources before their parents to prevent error with
        # foreign key constraint
        resources.sort(
            key=lambda x: 'b' if x.parent_resource_id is None else 'a')
        for output_resource in resources:
            output_resource.delete_instance()

    def _delete_object(self):
        """Delete the kv_store and the file if they exist does not delete model in DB
        """
        if self.fs_node_model:
            self.fs_node_model.delete_object()

        # TODO to improve, if there is an error, the kvstore is not restored
        self.remove_kv_store()

    def remove_kv_store(self):
        """
        Remove the kv store if it exists
        """
        kv_store: Optional[KVStore] = self.get_kv_store()
        if kv_store:
            kv_store.remove()

    @classmethod
    def drop_table(cls, *args, **kwargs):
        """
        Drop model table
        """

        if not cls.table_exists():
            return

        super().drop_table(*args, **kwargs)

    @classmethod
    def select_by_resource_typing_name(cls, resource_typing_name: str) -> ModelSelect:
        return cls.select_me().where(cls.resource_typing_name == resource_typing_name)

    @classmethod
    def select_by_type_and_sub_types(cls, type_: Type[Resource]) -> ModelSelect:
        """select resource by type of any subclass of this type

        :param type_: _description_
        :type type_: Type[Resource]
        :return: _description_
        :rtype: ModelSelect
        """
        if not Utils.issubclass(type_, Resource):
            raise Exception(f"{type_} is not a subclass of Resource")

        # retrieve all the sub type of the type
        resource_types: Set[Type[Resource]] = {
            type_}.union(Utils.get_all_subclasses(type_))
        # get the typing names
        resource_typing_names = [
            resource_type._typing_name for resource_type in resource_types]
        # select the resource model with the typing name
        return ResourceModel.select().where(ResourceModel.resource_typing_name.in_(resource_typing_names))

    @transaction()
    def save_full(self) -> 'ResourceModel':
        """Save the resource and the fs_node if exists

        :return: [description]
        :rtype: [type]
        """
        if self.fs_node_model:
            self.fs_node_model.save()
        self.save()

        return self

    @classmethod
    def after_table_creation(cls) -> None:
        super().after_table_creation()
        cls.create_full_text_index(['data'], 'I_F_RES_DATA')

    @classmethod
    def after_all_tables_init(cls) -> None:
        """Create the foreign keys because it was deffered
        """
        cls.create_foreign_key_if_not_exist(ResourceModel.experiment)
        cls.create_foreign_key_if_not_exist(ResourceModel.task_model)

    @classmethod
    def get_by_experiment(cls, experiment_id: str) -> ModelSelect:
        return ResourceModel.select().where(ResourceModel.experiment == experiment_id)

    @classmethod
    def get_by_experiments(cls, experiment_ids: List[str]) -> ModelSelect:
        return ResourceModel.select().where(ResourceModel.experiment.in_(experiment_ids))

    @classmethod
    def get_by_task_models(cls, task_model_ids: List[str]) -> ModelSelect:
        return ResourceModel.select().where(ResourceModel.task_model.in_(task_model_ids))

    @classmethod
    def delete_list(cls, resource_model_ids: str) -> ModelDelete:
        return ResourceModel.delete().where(ResourceModel.id.in_(resource_model_ids))

    @classmethod
    def get_by_types_and_sub_expression(cls, typing_names: List[str]) -> Expression:
        """Return the expression to search resource base on a type and all its subtypes.

        If the Resource type is provided, it returns None
        """

        # If the main resource class is provided, return None because all the classes will be retrieved
        if Resource._typing_name in typing_names:
            return None

        # Retrieve all type of typing_names
        resource_types: List[Type] = [TypingManager.get_type_from_name(
            typing_name) for typing_name in typing_names]

        # Get all type of class and subclasses
        all_types: Set[Type[Resource]] = set()
        for resource_type in resource_types:
            all_types.update(Utils.get_all_subclasses(resource_type))
            all_types.update([resource_type])

        # Get the typing names
        all_typing_names: List[str] = [
            resource_type._typing_name for resource_type in all_types]

        return ResourceModel.resource_typing_name.in_(all_typing_names)

    @classmethod
    def get_by_types_and_sub(cls, typing_names: List[str]) -> ModelSelect:
        return ResourceModel.select().where(cls.get_by_types_and_sub_expression(typing_names))

    @classmethod
    def check_if_any_resource_is_used_in_another_exp(cls, resources: List[ResourceModel], experiment_id: str) -> None:
        """Raised an exception if one of the resources if used in another experiment. As input or as config of a Source task
        """
        from ..task.task_input_model import TaskInputModel
        from ..task.task_model import TaskModel

        if len(resources) > 0:
            resource_ids: List[str] = list(
                map(lambda x: x.id, resources))

            # check if it is used as input
            other_experiment: TaskInputModel = TaskInputModel.get_other_experiments(
                resource_ids, experiment_id).first()

            if other_experiment is not None:
                raise ResourceUsedInAnotherExperimentException(
                    other_experiment.resource_model.name,
                    other_experiment.resource_model.id,
                    other_experiment.experiment.get_short_name(),
                    other_experiment.experiment.id)

            # check if it is used as source
            other_task: TaskModel = TaskModel.get_source_task_using_resource_in_another_experiment(
                resource_ids, experiment_id).first()

            if other_task is not None:
                # retrieve the resource model
                resource_model: ResourceModel = [
                    x for x in resources if x.id == other_task.source_config_id][0]
                raise ResourceUsedInAnotherExperimentException(
                    resource_model.name,
                    resource_model.id,
                    other_task.experiment.get_short_name(),
                    other_task.experiment.id)

    ########################################## RESOURCE ######################################

    @property
    def typing_name(self) -> str:
        return self._typing_name

    @final
    def get_resource(self, new_instance: bool = False) -> Resource:
        """
        Returns the resource created from the data and resource_typing_name
        if new_instance, it forces to rebuild the resource
        """

        if new_instance:
            return self._instantiate_resource()

        if self._resource is None:
            self._resource = self._instantiate_resource()

        return self._resource

    def _instantiate_resource(self) -> Resource:
        """
        Create the Resource object from the resource_typing_name
        """

        return ResourceFactory.create_resource(self.get_resource_type(),
                                               kv_store=self.get_kv_store(), data=self.data,
                                               resource_model_id=self.id, name=self.name)

    @classmethod
    def from_resource(cls, resource: Resource, origin: ResourceOrigin = ResourceOrigin.GENERATED,
                      experiment: Experiment = None, task_model: TaskModel = None, port_name: str = None) -> ResourceModel:
        """Create a new ResourceModel from a resource

        Don't set the resource here so it is regenerate on next get (avoid using same instance)

        :return: [description]
        :rtype: [type]
        """

        # If the origin is not uploaded, then the experiment and the task must be provided
        if origin not in [ResourceOrigin.UPLOADED, ResourceOrigin.ACTIONS, ResourceOrigin.S3_PROJECT_STORAGE]:
            if experiment is None or task_model is None:
                raise Exception(
                    "To create a GENERATED resource, you must provide the experiment and the task")

            # replace the origin if the experiment has a special type
            if experiment.type == ExperimentType.IMPORTER:
                origin = ResourceOrigin.IMPORTED
            elif experiment.type == ExperimentType.TRANSFORMER:
                origin = ResourceOrigin.TRANSFORMED
            elif experiment.type == ExperimentType.ACTIONS:
                origin = ResourceOrigin.ACTIONS
            elif experiment.type == ExperimentType.RESOURCE_DOWNLOADER:
                origin = ResourceOrigin.IMPORTED_FROM_LAB

        resource_model: ResourceModel = ResourceModel()
        resource_model.set_resource_typing_name(resource._typing_name)
        resource_model.origin = origin
        if experiment:
            resource_model.experiment = experiment
            resource_model.project = experiment.project
        resource_model.task_model = task_model
        resource_model.generated_by_port_name = port_name
        # by default only the uploaded resource are showed in databox
        resource_model.flagged = resource_model.is_manually_generated()

        # Get the name of the resource, and set it in the resource model
        name: str = None
        try:
            name = resource.name or resource.get_default_name()
        except Exception as err:
            Logger.error(
                f'Error while getting the default name of the resource {type(resource)}. Err : {str(err)}')
            Logger.log_exception_stack_trace(err)

        if name is None:
            name = resource._human_name
        resource_model.name = name

        if isinstance(resource, FSNode):
            resource_model.init_fs_node_model(resource, name)

        # synchronize the model fields with the resource fields
        resource_model.receive_fields_from_resource(resource)

        # set the resource model id in the resource
        # it can be useful for the resource to have access to the model id
        # in the run_after_task method for example
        resource._model_id = resource_model.id

        return resource_model

    def init_fs_node_model(self, resource: FSNode, name: str):
        node: FSNode

        local_file_store = LocalFileStore.get_default_instance()
        if not local_file_store.node_exists(resource):
            # Move the node to the LocalFileStore and create fs node model
            node = LocalFileStore.get_default_instance().add_node_from_path(resource.path, name)
        else:
            # On uploaded resource, the node is already in the file store, no need to add it
            node = resource
            node.file_store_id = local_file_store.id

        # update the resource path and file store
        resource.path = node.path
        resource.file_store_id = node.file_store_id

        # create the node model
        fs_node_model: FSNodeModel = FSNodeModel()
        fs_node_model.path = node.path
        fs_node_model.file_store_id = node.file_store_id
        fs_node_model.size = node.get_size()
        fs_node_model.is_symbolic_link = node.is_symbolic_link
        self.fs_node_model = fs_node_model

    @classmethod
    def save_from_resource(
            cls, resource: Resource, origin: ResourceOrigin = ResourceOrigin.GENERATED, experiment: Experiment = None,
            task_model: TaskModel = None, port_name: str = None) -> ResourceModel:
        """Create the ResourceModel from the Resource and save it
        """
        resource_model = cls.from_resource(
            resource, origin=origin, experiment=experiment, task_model=task_model, port_name=port_name).save_full()

        if resource.tags and isinstance(resource.tags, TagList):
            # Add tags
            entity_tags: EntityTagList = EntityTagList(EntityTagType.RESOURCE, resource_model.id)

            entity_tags.add_tags_to_entity(resource.tags.get_tags())
        return resource_model

    def set_resource_typing_name(self, typing_name: str) -> None:
        typing: Typing = TypingManager.get_typing_from_name_and_check(
            typing_name)
        self.resource_typing_name = typing_name
        self.brick_version = typing.brick_version

    def receive_fields_from_resource(self, resource: Resource):
        """for each BaseRField of the resource, store its value to the data or kvstore

        :param resource: [description]
        :type resource: Resource
        """
        self.data = {}
        # init the kvstore, the directory is not created until we write on the kvstore
        kv_store: KVStore = self._get_or_create_kv_store()

        # get the r_fields of the resource
        r_fields: Dict[str, BaseRField] = resource.__get_resource_r_fields__()

        for key, r_field in r_fields.items():
            # get the attribute value corresponding to the r_field
            r_field_value: Any = getattr(resource, key)

            # specific case for the FileRField
            if isinstance(r_field, FileRField):
                # generate a new file path inside the kv store directory
                file_path = kv_store.generate_new_file()

                # dump the resource value into the file
                r_field.dump_to_file(r_field_value, str(file_path))
                # store the file name (not absolute path) in the kv_store
                kv_store[key] = FileHelper.get_name(file_path)
                continue

            value: Any = r_field.serialize(r_field_value)
            # If the property is searchable, store it in the DB
            if r_field.searchable:
                self.data[key] = value

            # Otherwise, store it in the kvstore
            else:
                kv_store[key] = value

    def _get_resource_r_fields(self, resource_type: Type[Resource]) -> Dict[str, BaseRField]:
        """Get the list of resource's r_fields,
        the key is the property name, the value is the BaseRField object
        """
        return ReflectorHelper.get_property_names_of_type(resource_type, BaseRField)

    def get_resource_type(self) -> Type[Resource]:
        return TypingManager.get_type_from_name(self.resource_typing_name)

    ########################################## KV STORE ######################################

    @final
    def get_kv_store(self) -> Optional[KVStore]:
        if not self.kv_store_path:
            return None

        # Create the KVStore from the path
        kv_store: KVStore = KVStore(self.kv_store_path)

        # Lock the kvstore so the file can't be updated
        kv_store.lock(KVStore.get_full_file_path(
            file_name=self.id, with_extension=False))
        return kv_store

    def _get_or_create_kv_store(self) -> KVStore:
        """Get the KVStore and create an empty one if it doesn't exist

        :return: [description]
        :rtype: KVStore
        """
        kv_store: Optional[KVStore] = self.get_kv_store()
        if kv_store:
            return kv_store

        # Create the KV store
        kv_store = KVStore.from_filename(self.id)

        self.kv_store_path = kv_store.get_full_path_without_extension()
        return kv_store

    ########################################## JSON ######################################

    def to_json(self, deep: bool = False, **kwargs) -> dict:
        """
        Returns JSON string or dictionnary representation of the model.

        :param stringify: If True, returns a JSON string. Returns a python dictionary otherwise. Defaults to False
        :type stringify: bool
        :param prettify: If True, indent the JSON string. Defaults to False.
        :type prettify: bool
        :return: The representation
        :rtype: dict, str
        """

        _json = super().to_json(deep=deep, **kwargs)

        if self.fs_node_model:
            _json["fs_node"] = self.fs_node_model.to_json()

        if self.experiment is not None:
            _json["experiment"] = {
                'id': self.experiment.id,
                'title': self.experiment.title,
            }

        if self.project is not None:
            _json["project"] = {
                'id': self.project.id,
                'title': self.project.title,
                'code': self.project.code,
            }

        resource_typing: Optional[Typing] = TypingManager.get_typing_from_name(
            self.resource_typing_name)
        if resource_typing:
            _json["resource_type_human_name"] = resource_typing.human_name
            _json["resource_type_short_description"] = resource_typing.short_description
            _json["is_downloadable"] = self.is_downloadable
            _json["type_status"] = resource_typing.get_type_status()

            resource_type: Resource = resource_typing.get_type()

            # check if the resource has children resources
            if resource_type is not None and Utils.issubclass(resource_type, ResourceListBase):
                _json["has_children"] = True
            else:
                _json["has_children"] = False
        else:
            _json["type_status"] = TypingStatus.UNAVAILABLE

        return _json

    def export_config(self) -> dict:
        return {
            'id': self.id,
            'name': self.name,
            'resource_typing_name': self.resource_typing_name,
        }

    def data_to_json(self, deep: bool = False, **kwargs) -> dict:
        """
        Returns a JSON string or dictionnary representation of the model data.
        :return: The representation
        :rtype: `dict`
        """
        return {}

    ########################################## OTHER ######################################

    def get_technical_info(self) -> TechnicalInfoDict:
        kv_store = self.get_kv_store()
        if 'technical_info' in kv_store:
            return TechnicalInfoDict.deserialize(kv_store.get('technical_info'))
        return TechnicalInfoDict()

    @property
    def is_downloadable(self) -> bool:
        # the resource is downloadable if it's a file or if the export_to_path is defined
        resource_type: Resource = self.get_resource_type()
        return self.fs_node_model is not None or (resource_type is not None and resource_type._is_exportable)

    def is_manually_generated(self) -> bool:
        return self.origin == ResourceOrigin.UPLOADED
