

from __future__ import annotations

from typing import TYPE_CHECKING, Any, Dict, List, Optional, Set, Type, final

from peewee import (BooleanField, CharField, DeferredForeignKey, Expression,
                    ForeignKeyField, ModelDelete, ModelSelect)

from gws_core.core.model.db_field import BaseDTOField, JSONField
from gws_core.core.utils.utils import Utils
from gws_core.entity_navigator.entity_navigator_type import (EntityType,
                                                             NavigableEntity)
from gws_core.folder.model_with_folder import ModelWithFolder
from gws_core.folder.space_folder import SpaceFolder
from gws_core.impl.file.file_helper import FileHelper
from gws_core.model.typing_dto import TypingRefDTO, TypingStatus
from gws_core.model.typing_style import TypingStyle
from gws_core.resource.resource_dto import (ResourceModelDTO, ResourceOrigin,
                                            ResourceSimpleDTO)
from gws_core.resource.resource_set.resource_list_base import ResourceListBase
from gws_core.resource.technical_info import TechnicalInfoDict
from gws_core.tag.entity_tag_list import EntityTagList
from gws_core.tag.tag_list import TagList

from ..core.classes.enum_field import EnumField
from ..core.decorator.transaction import transaction
from ..core.exception.exceptions.bad_request_exception import \
    BadRequestException
from ..core.model.model_with_user import ModelWithUser
from ..core.utils.logger import Logger
from ..core.utils.reflector_helper import ReflectorHelper
from ..impl.file.file_r_field import FileRField
from ..impl.file.fs_node import FSNode
from ..impl.file.fs_node_model import FSNodeModel
from ..impl.file.local_file_store import LocalFileStore
from ..model.typing import Typing
from ..model.typing_manager import TypingManager
from ..resource.kv_store import KVStore
from ..resource.resource import Resource
from .r_field.r_field import BaseRField
from .resource_factory import ResourceFactory

if TYPE_CHECKING:
    from ..scenario.scenario import Scenario
    from ..task.task_model import TaskModel


class ResourceModel(ModelWithUser, ModelWithFolder, NavigableEntity):

    """
    ResourceModel class.
    """

    # typing name of the resource
    resource_typing_name = CharField(null=False)

    # Path to the kv store if the kv exists for this resource model
    kv_store_path = CharField(null=True)

    origin: ResourceOrigin = EnumField(
        choices=ResourceOrigin, default=ResourceOrigin.GENERATED)

    scenario: Scenario = DeferredForeignKey(
        'Scenario', null=True, index=True)
    folder: SpaceFolder = ForeignKeyField(SpaceFolder, null=True, index=True)
    task_model: TaskModel = DeferredForeignKey(
        'TaskModel', null=True, index=True)

    # for children resource (usually resource inside ResourceSet), it stores the parent resource id
    # lazy_load = False to avoir loading the resource, and it only contains the id
    parent_resource_id: str = ForeignKeyField(
        'self', null=True, index=True, lazy_load=False)

    name: str = CharField(null=False)

    fs_node_model: FSNodeModel = ForeignKeyField(
        FSNodeModel, null=True, index=True, backref="+")

    # true when the resource is UPLOADED or is a scenario output
    flagged: bool = BooleanField(default=False)

    # provided when the resource is generated by a scenario, this contains the port name of the task that generated it
    generated_by_port_name: str = CharField(null=True)

    brick_version = CharField(null=False, max_length=50, default="")

    data: Dict[str, Any] = JSONField(null=True)
    is_archived = BooleanField(default=False, index=True)

    # true if the resource content was deleted
    # when cleaning intermediate resources or importing an experience without the intermediate resources
    content_is_deleted = BooleanField(default=False)
    style: TypingStyle = BaseDTOField(TypingStyle, null=False)

    _table_name = 'gws_resource'
    _resource: Resource = None

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        if not self.is_saved() and not self.data:
            self.data = {}

    ########################################## MODEL METHODS ######################################

    @transaction()
    def delete_instance(self, *args, **kwargs):
        # fs_node_model: FSNodeModel = self.fs_node_model
        result = super().delete_instance(*args, **kwargs)
        EntityTagList.delete_by_entity(EntityType.RESOURCE, self.id)

        if self.fs_node_model:
            self.fs_node_model.delete_instance()
        # TODO to improve, if there is an error, the kvstore is not restored
        self.remove_kv_store()
        return result

    @transaction()
    def delete_resource_content(self) -> 'ResourceModel':
        """
        Delete the content of the resource, the data, the kv store and the fs node
        """
        fs_node_model = self.fs_node_model

        self.content_is_deleted = True
        self.fs_node_model = None
        self.save()

        if fs_node_model:
            fs_node_model.delete_instance()
        # TODO to improve, if there is an error, the kvstore is not restored
        self.remove_kv_store()
        return self

    @transaction()
    def archive(self, archive: bool) -> 'ResourceModel':
        """
        Archive the process
        """

        if self.is_archived == archive:
            return self

        self.is_archived = archive
        return self.save()

    @classmethod
    def delete_multiple_resources(cls, resources: List[ResourceModel]):
        # sort the resources to have children resources before their parents to prevent error with
        # foreign key constraint
        resources.sort(
            key=lambda x: 'b' if x.parent_resource_id is None else 'a')
        for output_resource in resources:
            output_resource.delete_instance()

    @classmethod
    def delete_resource_by_task_model(cls, task_model_id: str) -> None:
        task_resources: List[ResourceModel] = list(ResourceModel.get_by_task_model(task_model_id).execute())

        cls.delete_multiple_resources(task_resources)

    def remove_kv_store(self):
        """
        Remove the kv store if it exists
        """
        kv_store: Optional[KVStore] = self.get_kv_store()
        if kv_store:
            kv_store.remove()

    @classmethod
    def select_by_resource_typing_name(cls, resource_typing_name: str) -> ModelSelect:
        return cls.select().where(cls.resource_typing_name == resource_typing_name)

    @classmethod
    def select_by_type_and_sub_types(cls, type_: Type[Resource]) -> ModelSelect:
        """select resource by type of any subclass of this type

        :param type_: _description_
        :type type_: Type[Resource]
        :return: _description_
        :rtype: ModelSelect
        """
        if not Utils.issubclass(type_, Resource):
            raise Exception(f"{type_} is not a subclass of Resource")

        return ResourceModel.select().where(cls.get_by_types_and_sub_expression([type_.get_typing_name()]))

    @transaction()
    def save_full(self) -> 'ResourceModel':
        """Save the resource and the fs_node if exists

        :return: [description]
        :rtype: [type]
        """
        if self.fs_node_model:
            self.fs_node_model.save()
        self.save()

        return self

    @classmethod
    def after_table_creation(cls) -> None:
        super().after_table_creation()
        cls.create_full_text_index(['data'], 'I_F_RES_DATA')

    @classmethod
    def after_all_tables_init(cls) -> None:
        """Create the foreign keys because it was deffered
        """
        cls.create_foreign_key_if_not_exist(ResourceModel.scenario)
        cls.create_foreign_key_if_not_exist(ResourceModel.task_model)

    @classmethod
    def get_by_scenario(cls, scenario_id: str) -> ModelSelect:
        return ResourceModel.select().where(ResourceModel.scenario == scenario_id)

    @classmethod
    def get_by_scenarios(cls, scenario_ids: List[str]) -> ModelSelect:
        return ResourceModel.select().where(ResourceModel.scenario.in_(scenario_ids))

    @classmethod
    def get_by_task_model(cls, task_model_id: str) -> ModelSelect:
        return ResourceModel.select().where(ResourceModel.task_model == task_model_id)

    @classmethod
    def get_by_task_models(cls, task_model_ids: List[str]) -> ModelSelect:
        return ResourceModel.select().where(ResourceModel.task_model.in_(task_model_ids))

    @classmethod
    def find_by_fs_node_id(cls, fs_node_id: str) -> Optional['ResourceModel']:
        return cls.select().where(cls.fs_node_model == fs_node_id).first()

    @classmethod
    def delete_list(cls, resource_model_ids: str) -> ModelDelete:
        return ResourceModel.delete().where(ResourceModel.id.in_(resource_model_ids))

    @classmethod
    def get_by_types_and_sub_expression(cls, typing_names: List[str]) -> Expression:
        """Return the expression to search resource base on a type and all its subtypes.

        If the Resource type is provided, it returns None
        """

        # If the main resource class is provided, return None because all the classes will be retrieved
        if Resource.get_typing_name() in typing_names:
            return None

        # Retrieve all type of typing_names
        resource_types: List[Type] = [TypingManager.get_type_from_name(
            typing_name) for typing_name in typing_names]

        # Get all type of class and subclasses
        all_types: Set[Type[Resource]] = set()
        for resource_type in resource_types:
            all_types.update(Utils.get_all_subclasses(resource_type))
            all_types.update([resource_type])

        # Get the typing names
        all_typing_names: List[str] = [
            resource_type.get_typing_name() for resource_type in all_types]

        return ResourceModel.resource_typing_name.in_(all_typing_names)

    @classmethod
    def get_by_types_and_sub(cls, typing_names: List[str]) -> ModelSelect:
        return ResourceModel.select().where(cls.get_by_types_and_sub_expression(typing_names))

    @classmethod
    def get_resource_by_scenario_and_flag(cls, scenario_id: str, flagged: bool) -> ModelSelect:
        return ResourceModel.select().where(ResourceModel.scenario == scenario_id,
                                            ResourceModel.flagged == flagged)
    ########################################## RESOURCE ######################################

    @final
    def get_resource(self, new_instance: bool = False) -> Resource:
        """
        Returns the resource created from the data and resource_typing_name
        if new_instance, it forces to rebuild the resource
        """
        if self.content_is_deleted:
            raise BadRequestException(
                f"Intermediate resource '{self.name}' was deleted, can't get the resource data")

        if new_instance:
            return self._instantiate_resource()

        if self._resource is None:
            self._resource = self._instantiate_resource()

        return self._resource

    def _instantiate_resource(self) -> Resource:
        """
        Create the Resource object from the resource_typing_name
        """

        return ResourceFactory.create_resource(self.get_and_check_resource_type(),
                                               kv_store=self.get_kv_store(), data=self.data,
                                               resource_model_id=self.id, name=self.name,
                                               style=self.style)

    @classmethod
    def from_resource(cls, resource: Resource, origin: ResourceOrigin = ResourceOrigin.GENERATED,
                      scenario: Optional[Scenario] = None, task_model: Optional[TaskModel] = None,
                      port_name: str = None, flagged: bool = None) -> ResourceModel:
        """Create a new ResourceModel from a resource

        Don't set the resource here so it is regenerate on next get ( avoid using same instance)

        :return: [description]
        :rtype: [type]
        """

        resource_model: ResourceModel = ResourceModel()
        resource_model.origin = resource.__origin__ or origin

        # If the origin is not uploaded, then the scenario and the task must be provided
        if resource_model.origin not in [
                ResourceOrigin.UPLOADED, ResourceOrigin.S3_FOLDER_STORAGE, ResourceOrigin.IMPORTED_FROM_LAB]:
            if scenario is None or task_model is None:
                raise Exception(f"To create a {origin} resource, you must provide the scenario and the task")

        # if the resource is imported and its id is define, use it
        # with this resources imported from another can keep their id
        if resource_model.origin == ResourceOrigin.IMPORTED_FROM_LAB and resource.get_model_id() is not None:
            resource_model.id = resource.get_model_id()

        resource_model.set_resource_typing_name(resource.get_typing_name())

        if scenario:
            resource_model.scenario = scenario
            resource_model.folder = scenario.folder
        resource_model.task_model = task_model
        resource_model.generated_by_port_name = port_name

        if flagged is not None:
            resource_model.flagged = flagged
        else:
            # by default only the uploaded resource are showed in list
            resource_model.flagged = resource_model.is_manually_generated()

        if isinstance(resource, FSNode):
            resource_model.init_fs_node_model(resource)

        # Get the name of the resource, and set it in the resource model
        name: str = None
        try:
            name = resource.name or resource.get_default_name()
        except Exception as err:
            Logger.error(
                f'Error while getting the default name of the resource {type(resource)}. Err : {str(err)}')
            Logger.log_exception_stack_trace(err)

        if name is None:
            name = resource.get_human_name()
        resource_model.name = name

        style_override = resource.style
        if style_override:
            style_override.fill_empty_values()
            resource_model.style = style_override
        else:
            resource_model.style = resource.get_default_style()

        # synchronize the model fields with the resource fields
        resource_model.receive_fields_from_resource(resource)

        # set the resource model id in the resource
        # it can be useful for the resource to have access to the model id
        # in the run_after_task method for example
        resource.__set_model_id__(resource_model.id)

        return resource_model

    def init_fs_node_model(self, resource: FSNode) -> FSNode:

        local_file_store = LocalFileStore.get_default_instance()

        # for symbolic link, the file must be in the file store
        if resource.is_symbolic_link:
            if not local_file_store.node_exists(resource):
                raise Exception(
                    f"Attempting to save a new symbolic link resource with path '{resource.path}' that does not exist in the file store. Please check that the path of the symbolic link is correct and that the target file or folder exists.")

        else:
            # For normal node, the file must not be in the file store
            if local_file_store.node_exists(resource):
                raise Exception(
                    f"Attempting to save a new File or Folder resource with path '{resource.path}' that already exists in the file store. Please do not create file directly in file store. And the path of the output File or Folder must not be the same as the path of an input File or Folder, if this is required, please set 'is_symbolic_link' to True on File or Folder.")

            new_node_path = local_file_store.generate_new_node_path(resource.get_base_name())
            new_node_name = FileHelper.get_name_with_extension(new_node_path)

            # Verify if a node with same path already exists
            existing_node: FSNodeModel = FSNodeModel.find_by_path(new_node_path)
            # if the path exist in DB but not in the file store, it means that the file was manually deleted
            # so we consider it as deleted
            if existing_node is not None and not local_file_store.node_name_exists(new_node_name):
                # mark the resource contet of the node as deleted
                resource_model_to_delete = ResourceModel.find_by_fs_node_id(existing_node.id)

                # mark the content of the resource as deleted
                if resource_model_to_delete is not None:
                    Logger.info(
                        f"Detecting that the fs node of the resource '{resource_model_to_delete.id}' was deleted. Marking the content as deleted.")
                    resource_model_to_delete.delete_resource_content()
                # this should not happen, but if it does, we delete the node
                else:
                    existing_node.delete_instance()

            # Move the node to the LocalFileStore using the new generated name
            new_node: FSNode = local_file_store.add_node_from_path(
                resource.path, new_node_name)

            # update the resource path and file store
            resource.path = new_node.path
            resource.file_store_id = new_node.file_store_id

        # create the node model
        new_fs_node_model = FSNodeModel()
        new_fs_node_model.path = resource.path
        new_fs_node_model.file_store_id = resource.file_store_id
        new_fs_node_model.size = resource.get_size()
        new_fs_node_model.is_symbolic_link = resource.is_symbolic_link
        self.fs_node_model = new_fs_node_model

        return resource

    @classmethod
    def save_from_resource(
            cls, resource: Resource, origin: ResourceOrigin = ResourceOrigin.GENERATED, scenario: Scenario = None,
            task_model: TaskModel = None, port_name: str = None, flagged: bool = None) -> ResourceModel:
        """Create the ResourceModel from the Resource and save it
        """
        # FIX is flagged and export ResourceOrigin
        resource_model = cls.from_resource(
            resource, origin=origin, scenario=scenario, task_model=task_model, port_name=port_name,
            flagged=flagged).save_full()

        if resource.tags and isinstance(resource.tags, TagList):
            # Add tags
            entity_tags: EntityTagList = EntityTagList(EntityType.RESOURCE, resource_model.id)

            entity_tags.add_tags(resource.tags.get_tags())
        return resource_model

    def set_resource_typing_name(self, typing_name: str) -> None:
        typing: Typing = TypingManager.get_typing_from_name_and_check(
            typing_name)
        self.resource_typing_name = typing_name
        self.brick_version = typing.brick_version

    def receive_fields_from_resource(self, resource: Resource):
        """for each BaseRField of the resource, store its value to the data or kvstore

        :param resource: [description]
        :type resource: Resource
        """
        self.data = {}
        # init the kvstore, the directory is not created until we write on the kvstore
        kv_store: KVStore = self._get_or_create_kv_store()

        # get the r_fields of the resource
        r_fields: Dict[str, BaseRField] = resource.__get_resource_r_fields__()

        for key, r_field in r_fields.items():
            # get the attribute value corresponding to the r_field
            r_field_value: Any = getattr(resource, key)

            # specific case for the FileRField
            if isinstance(r_field, FileRField):
                # generate a new file path inside the kv store directory
                file_path = kv_store.generate_new_file()

                # dump the resource value into the file
                r_field.dump_to_file(r_field_value, str(file_path))
                # store the file name (not absolute path) in the kv_store
                kv_store[key] = FileHelper.get_name(file_path)
                continue

            value: Any = r_field.serialize(r_field_value)
            # If the property is searchable, store it in the DB
            if r_field.searchable:
                self.data[key] = value

            # Otherwise, store it in the kvstore
            else:
                kv_store[key] = value

    def _get_resource_r_fields(self, resource_type: Type[Resource]) -> Dict[str, BaseRField]:
        """Get the list of resource's r_fields,
        the key is the property name, the value is the BaseRField object
        """
        return ReflectorHelper.get_property_names_of_type(resource_type, BaseRField)

    def get_resource_type(self) -> Optional[Type[Resource]]:
        return TypingManager.get_type_from_name(self.resource_typing_name)

    def get_and_check_resource_type(self) -> Type[Resource]:
        return TypingManager.get_and_check_type_from_name(self.resource_typing_name)

    def set_parent_and_save(self, parent_resource_id: str) -> 'ResourceModel':
        self.parent_resource_id = parent_resource_id
        return self.save()

    ########################################## KV STORE ######################################

    @final
    def get_kv_store(self) -> Optional[KVStore]:
        if not self.kv_store_path:
            return None

        # Create the KVStore from the path
        kv_store: KVStore = KVStore(self.kv_store_path)

        # Lock the kvstore so the file can't be updated
        kv_store.lock(KVStore.get_full_file_path(
            file_name=self.id, with_extension=False))
        return kv_store

    def _get_or_create_kv_store(self) -> KVStore:
        """Get the KVStore and create an empty one if it doesn't exist

        :return: [description]
        :rtype: KVStore
        """
        kv_store: Optional[KVStore] = self.get_kv_store()
        if kv_store:
            return kv_store

        # Create the KV store
        kv_store = KVStore.from_filename(self.id)

        self.kv_store_path = kv_store.get_full_path_without_extension()
        return kv_store

    ########################################## JSON ######################################

    def to_dto(self) -> ResourceModelDTO:

        resource_type_ref: TypingRefDTO = None
        is_downloadable: Optional[bool] = False
        type_status: TypingStatus = TypingStatus.OK
        has_children: bool = False

        resource_typing: Optional[Typing] = TypingManager.get_typing_from_name(
            self.resource_typing_name)
        if resource_typing:
            resource_type_ref = resource_typing.to_ref_dto()
            is_downloadable = self.is_downloadable
            type_status = resource_typing.get_type_status()

            resource_type: Type = resource_typing.get_type()

            # check if the resource has children resources
            if resource_type is not None and Utils.issubclass(resource_type, ResourceListBase):
                has_children = True
        else:
            type_status = TypingStatus.UNAVAILABLE

        return ResourceModelDTO(
            id=self.id,
            created_at=self.created_at,
            created_by=self.created_by.to_dto(),
            last_modified_at=self.last_modified_at,
            last_modified_by=self.last_modified_by.to_dto(),
            resource_typing_name=self.resource_typing_name,
            resource_type=resource_type_ref,
            fs_node=self.fs_node_model.to_dto() if self.fs_node_model else None,
            origin=self.origin,
            is_downloadable=is_downloadable,
            name=self.name,
            has_children=has_children,
            type_status=type_status,
            flagged=self.flagged,
            scenario=self.scenario.to_simple_dto() if self.scenario else None,
            folder=self.folder.to_dto() if self.folder else None,
            style=self.style
        )

    def to_simple_dto(self) -> ResourceSimpleDTO:
        return ResourceSimpleDTO(
            id=self.id,
            name=self.name,
        )

    def export_config(self) -> dict:
        return {
            'id': self.id,
            'name': self.name,
            'resource_typing_name': self.resource_typing_name,
        }

    ########################################## OTHER ######################################

    def get_technical_info(self) -> TechnicalInfoDict:
        kv_store = self.get_kv_store()
        if 'technical_info' in kv_store:
            return TechnicalInfoDict.deserialize(kv_store.get('technical_info'))
        return TechnicalInfoDict()

    @property
    def is_downloadable(self) -> bool:
        # the resource is downloadable if it's a file or if the export_to_path is defined
        resource_type: Type[Resource] = self.get_resource_type()
        return self.fs_node_model is not None or (resource_type is not None and resource_type.__is_exportable__)

    def is_manually_generated(self) -> bool:
        return self.origin == ResourceOrigin.UPLOADED or self.origin == ResourceOrigin.IMPORTED_FROM_LAB

    def get_entity_name(self) -> str:
        return self.name

    def get_entity_type(self) -> EntityType:
        return EntityType.RESOURCE

    def __str__(self):
        return self.name

    class Meta:
        table_name = 'gws_resource'
