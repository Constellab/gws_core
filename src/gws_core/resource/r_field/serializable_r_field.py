

from abc import abstractmethod
from typing import Any, Dict, List, Type, Union

from gws_core.core.utils.utils import Utils

from ...core.exception.exceptions.bad_request_exception import \
    BadRequestException
from .r_field import BaseRField


class SerializableObjectJson():
    """Serializable and deserializable object. It must be serialized into a json object and deserialized from a json object."""

    @abstractmethod
    def serialize(self) -> Union[Dict, List, str, bool, float]:
        """ Serialize the object into a json object.
        For SerializableRField, this method is called when the resource is saved.

        :return: _description_
        :rtype: Union[Dict, List, str, bool, float]
        """

    @classmethod
    @abstractmethod
    def deserialize(cls, data: Union[Dict, List, str, bool, float]) -> 'SerializableObjectJson':
        """ Deserialize the object from a json object.
        For SerializableRField, this method is called when the RField is loaded.

        :param data: json object generated by the serialize method
        :type data: Union[Dict, List, str, bool, float]
        :return: _description_
        :rtype: SerializableObjectJson
        """


class SerializableRField(BaseRField):

    object_type: Type[SerializableObjectJson]

    def __init__(self, object_type: Type[SerializableObjectJson], include_in_dict_view: bool = False) -> None:
        """
        RField to serialize and deserialize python object to and from json
        :param object_type: type of the jsonable object. This type is instantiated when the resource is created. It must have a constructor with no parameter.
        :type object_type: Type[SerializableObject], optional
        :param include_in_dict_view: if true, this field we be included in the default dict view
                              Do not mark huge fields as include in dict view, defaults to False
        :type include_in_dict_view: bool, optional
        """
        if not Utils.issubclass(object_type, SerializableObjectJson):
            raise BadRequestException("The object type must be a subclass of SerializableObject")
        super().__init__(searchable=False,
                         default_value=object_type, include_in_dict_view=include_in_dict_view)
        self.object_type = object_type

    def deserialize(self, r_field_value: Any) -> SerializableObjectJson:
        if r_field_value is None:
            return self.get_default_value()

        return self.object_type.deserialize(r_field_value)

    def serialize(self, r_field_value: SerializableObjectJson) -> Any:
        if r_field_value is None:
            return None

        if not isinstance(r_field_value, self.object_type):
            raise BadRequestException(f"The value must be a {self.object_type.__name__}")

        return r_field_value.serialize()
