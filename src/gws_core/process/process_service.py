# LICENSE
# This software is the exclusive property of Gencovery SAS.
# The use and distribution of this software is prohibited without the prior consent of Gencovery SAS.
# About us: https://gencovery.com


from datetime import timedelta
from typing import Literal, Type

from gws_core.core.exception.exceptions.bad_request_exception import \
    BadRequestException
from gws_core.core.utils.date_helper import DateHelper
from gws_core.lab.log.log import LogsBetweenDatesResponse
from gws_core.lab.log.log_service import LogService
from gws_core.process.process_model import ProcessModel, ProcessStatus
from gws_core.protocol.protocol_model import ProtocolModel
from gws_core.task.task_model import TaskModel

ProcessType = Literal['TASK', 'PROTOCOL']


class ProcessService:

    # add a margin of 2 seconds to avoid missing the first log lines and the last log lines
    LOG_SECOND_MARGIN = 2

    @classmethod
    def get_logs_of_process(
            cls, process_type: ProcessType, process_id: str, is_sub_process: bool = True) -> LogsBetweenDatesResponse:
        """Read the server log on filtered by the process start and end date
        """
        process_model: ProcessModel = cls.get_and_check_process_model(process_type, process_id)

        if process_model.status == ProcessStatus.DRAFT:
            raise BadRequestException("Can't get logs of a process in draft status")

        # add a margin of 2 seconds to avoid missing the first log lines and the last log lines
        start_date = process_model.started_at - timedelta(seconds=cls.LOG_SECOND_MARGIN)
        end_date = (process_model.ended_at or DateHelper.now_utc()) + timedelta(seconds=cls.LOG_SECOND_MARGIN)

        # retrieve the log generated by the process during the time
        return LogService.get_logs_between_dates(start_date, end_date, from_experiment=is_sub_process)

    @classmethod
    def get_and_check_process_model(cls, process_type: ProcessType, process_id: str) -> ProcessModel:
        process_type: Type[ProcessModel] = cls._get_class_from_type(process_type)
        return process_type.get_by_id_and_check(process_id)

    @classmethod
    def _get_class_from_type(cls, process_type: ProcessType) -> Type[ProcessModel]:
        if process_type == 'TASK':
            return TaskModel
        elif process_type == 'PROTOCOL':
            return ProtocolModel
        else:
            raise BadRequestException(f"Process type {process_type} does not exist")
