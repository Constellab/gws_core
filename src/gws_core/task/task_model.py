
from traceback import format_exc
from typing import Any, Dict, List, Type

from peewee import BooleanField, CharField, ForeignKeyField, ModelSelect

from gws_core.config.config import Config
from gws_core.core.utils.date_helper import DateHelper
from gws_core.entity_navigator.entity_navigator_type import EntityType
from gws_core.process.process import Process
from gws_core.resource.resource_dto import ResourceOrigin
from gws_core.resource.resource_set.resource_list_base import ResourceListBase
from gws_core.tag.entity_tag_list import EntityTagList
from gws_core.tag.tag import Tag
from gws_core.tag.tag_dto import TagOriginType
from gws_core.tag.tag_list import TagList
from gws_core.task.plug.input_task import InputTask

from ..config.config_types import ConfigParamsDict
from ..core.decorator.transaction import transaction
from ..core.exception.exceptions.bad_request_exception import \
    BadRequestException
from ..core.exception.gws_exceptions import GWSException
from ..core.utils.logger import Logger
from ..core.utils.reflector_helper import ReflectorHelper
from ..io.io_exception import InvalidOutputsException
from ..io.port import Port
from ..process.process_exception import (CheckBeforeTaskStopException,
                                         ProcessRunException)
from ..process.process_model import ProcessModel
from ..process.process_types import ProcessStatus
from ..resource.resource import Resource
from ..resource.resource_model import ResourceModel
from ..resource.resource_r_field import ResourceRField
from ..task.task_io import TaskOutputs
from .task import CheckBeforeTaskResult, Task
from .task_runner import TaskRunner


class TaskModel(ProcessModel):
    """
    Task model class.

    :property input_specs: The specs of the input
    :type input_specs: dict
    :property output_specs: The specs of the output
    :type output_specs: dict
    :property config_specs: The specs of the config
    :type config_specs: dict
    """

    # Only for task of type Input, this is to store the resource used in config
    # with lazy load = false, the Resource is not Loaded, it only contains the id
    source_config_id: str = ForeignKeyField(
        ResourceModel, null=True, index=True, lazy_load=False)

    community_agent_version_id: str = CharField(null=True, max_length=36, default="")

    community_agent_version_modified: bool = BooleanField(default=False)

    _table_name = 'gws_task'

    # cache to store the list of tags of all inputs
    _input_resource_tags: List[Tag] = None

    def set_process_type(self, process_type: Type[Process]) -> None:
        """Method used when creating a new task model, it init the input and output from task specs

        :param typing_name: type of the task
        :type typing_name: str
        """
        if not issubclass(process_type, Task):
            raise Exception(
                f"Error while setting the task type. The provided type '{process_type}' is not a subclass of Task")
        super().set_process_type(process_type)

    def _create_task_instance(self) -> Task:
        return self.get_process_type()()

    def is_protocol(self) -> bool:
        return False
    ################################# MODEL METHODS #############################

    def save_full(self) -> 'TaskModel':
        self.config.save()
        self.progress_bar.save()
        return self.save()

    @transaction()
    def archive(self, archive: bool) -> 'TaskModel':
        """
        Archive the process
        """

        if self.is_archived == archive:
            return self

        for resource in self.resources:
            resource.archive(archive)

        self.is_archived = archive
        return self.save()

    @transaction()
    def reset(self) -> 'ProcessModel':
        """
        Reset the process
        """
        from gws_core.task.task_input_model import TaskInputModel

        process = super().reset()

        # Delete the resources generated by this task
        ResourceModel.delete_resource_by_task_model(self.id)

        # Delete the TaskInputModel of this task
        TaskInputModel.delete_by_task_id(self.id)

        return process

    @property
    def resources(self) -> List[ResourceModel]:
        if not self.is_saved():
            return []

        return list(ResourceModel.select().where(ResourceModel.task_model == self))

    @classmethod
    def get_scenario_input_tasks(cls, scenario_ids: List[str]) -> ModelSelect:
        """Return all the Input task Model of the scenario
        """
        return cls.select().where((cls.scenario.in_(scenario_ids)) & (cls.source_config_id.is_null(False)))

    ################################# RUN #############################

    def _run(self) -> None:
        """
        Run the task and save its state in the database.
        """

        # build the task tester
        params: ConfigParamsDict = self.config.get_and_check_values()
        inputs: Dict[str, Resource] = self.inputs.get_resources(new_instance=True)

        task_runner: TaskRunner = TaskRunner(
            task_type=self.get_process_type(),
            params=params,
            inputs=inputs,
            config_model_id=self.config.id,
            input_specs=self.inputs.get_specs(),
            output_specs=self.outputs.get_specs(),
            config_specs=self.config.get_specs(),
            scenario_id=self.scenario.id if self.scenario else None
        )
        task_runner.set_progress_bar(self.progress_bar)

        check_result: CheckBeforeTaskResult
        try:
            check_result = task_runner.check_before_run()
        except Exception as err:
            Logger.log_exception_stack_trace(err)
            raise ProcessRunException.from_exception(process_model=self, exception=err,
                                                     error_prefix='Error during check before task') from err

        # If the check before task retuned False
        if isinstance(check_result, dict) and check_result.get('result') is False:
            raise CheckBeforeTaskStopException(
                message=check_result.get('message'))

        self._run_before_task()

        # run the task
        self._run_task(task_runner)

        # execute the run after task method
        try:
            task_runner.run_after_task()
        except Exception as err:
            if not isinstance(err, ProcessRunException):
                Logger.log_exception_stack_trace(err)
            raise ProcessRunException.from_exception(process_model=self, exception=err,
                                                     error_prefix='Error during check after task') from err

        # save the style of the task if provided
        style_override = task_runner.get_task().style
        if style_override:
            style_override.fill_empty_values()
            self.style = style_override

        self._run_after_task()
        self.mark_as_success()

    def _run_before_task(self) -> None:
        super()._run_before_task()

        # Store all the resources user as input for this taks
        self.save_input_resources()

    def save_input_resources(self) -> None:
        """Method run just before the task run to save the input resource for this task.
          this will allow to know what resource this task uses as input
        """
        from .task_input_model import TaskInputModel
        for port_name, port in self.inputs.ports.items():

            resource_model: ResourceModel = port.get_resource_model()

            if resource_model is None:
                continue

            if not resource_model.is_saved():
                raise Exception(
                    f"The resource of port '{port_name}' is not saved, it can't be used as input of the task")

            # Create the Input resource to save the resource use as input
            input_resource: TaskInputModel = TaskInputModel()
            input_resource.resource_model = resource_model
            input_resource.scenario = self.scenario
            input_resource.task_model = self

            parent = self.parent_protocol
            input_resource.protocol_model = parent
            input_resource.port_name = port_name
            input_resource.is_interface = parent.port_is_interface(self.instance_name, port_name)

            input_resource.save()

    def _run_task(self, task_runner: TaskRunner) -> None:
        """
        Run the task and save its state in the database.
        """

        try:
            # Run the task task
            task_runner.run()

        except InvalidOutputsException as err:
            # Save the valid resources
            self._save_outputs(task_runner.get_outputs())
            raise err
        except Exception as err:

            # only keep the section inside the task runner to have a clean trace
            # not working when the raised exception is catched and re-raised
            # exception_detail = ExceptionHelper.sub_traceback_to_str(err, inspect.getmodule(TaskRunner))
            exception_detail = str(format_exc())
            # log trace error
            self.progress_bar.add_error_message("Here is the error detail :\n" + exception_detail)
            raise ProcessRunException.from_exception(process_model=self, exception=err) from err

        # If success, save the outputs
        self._save_outputs(task_runner.get_outputs())

    def _save_outputs(self, task_outputs: TaskOutputs) -> None:

        for key, resource in task_outputs.items():

            if not self.outputs.port_exists(key):
                raise Exception(
                    f"Error while saving the task output. The port '{key}' does not exists")

            resource_model: ResourceModel

            port: Port = self.outputs.get_port(key)

            if port.is_constant_out:
                # If the port is mark as is_constant_out, we don't create a new resource
                # We use the same resource
                resource_model = ResourceModel.get_by_id_and_check(
                    resource.get_model_id())
            else:
                resource_model = self._save_output_resource(resource, port.name)

            # save the resource model into the output's port (even if it's None)
            port.set_resource_model(resource_model)

    def _save_output_resource(self, resource: Resource, port_name: str) -> ResourceModel:
        """Save the resource
        """
        self._check_resource_before_save(resource, port_name)

        # Handle specific case of ResourceSet, it saves all the sub
        new_children_resources: List[ResourceModel] = []
        if isinstance(resource, ResourceListBase):
            new_children_resources = self._save_resource_list_children(
                resource, port_name)

        # create and save the resource model from the resource
        resource_model = ResourceModel.save_from_resource(
            resource, origin=ResourceOrigin.GENERATED, scenario=self.scenario, task_model=self, port_name=port_name)

        # update the parent of new children resource
        if isinstance(resource, ResourceListBase):
            for child_resource in new_children_resources:
                child_resource.set_parent_and_save(resource_model)

        return resource_model

    def _check_resource_before_save(self, resource: Resource, port_name: str) -> None:
        # check the resource r field before saving
        self._check_resource_r_fields(resource, port_name)

        # Add the tag of the input resources to the new resource (tag propagation)
        if not resource.tags or not isinstance(resource.tags, TagList):
            resource.tags = TagList()
        else:
            # Specific case when the output resource is the same instance as an input resource
            # this is to remove the tags of the input resource
            resource.tags.remove_loaded_tags()

            # For all tag created by the task, mark the origin as created by the task.
            for tag in resource.tags.get_tags():
                tag.origins.set_origins(TagOriginType.TASK, self.id)

        # propagate the tag from input resources and scenario
        resource.tags.add_tags(self._get_input_resource_tags())
        resource.tags.add_tags(self._get_scenario_tags())

    def _save_resource_list_children(self, resource_list: ResourceListBase, port_name: str) -> List[ResourceModel]:
        """Specific management to save resources of a resource set, return the new created resources
        """

        for resource in resource_list.get_resources_as_set():

            # for constant resource, only check if it was set as input
            if resource_list.__resource_is_constant__(resource.uid):

                # verify that the resource exists
                if resource.get_model_id() is None:
                    raise Exception(
                        f"The resource with '{resource.name or resource.uid}' was added to a ResourceList with create_new_resource set to False but the resource does not exists in the system. It seems it wasn't saved in the database before, is it a new resource ?")
                # case when the resource is a constant and we don't create a new resource
                # if the resource is not listed in task input, error
                # Accept the resource if it is a sub resource of a input resource set
                if not self.inputs.has_resource_model(resource.get_model_id(), include_sub_resouces=True):
                    raise BadRequestException(GWSException.INVALID_LINKED_RESOURCE.value,
                                              unique_code=GWSException.INVALID_LINKED_RESOURCE.name,
                                              detail_args={'port_name': port_name})
            else:
                self._check_resource_before_save(resource, port_name)

        return resource_list.save_new_children_resources(ResourceOrigin.GENERATED, self.scenario, self, port_name)

    def _check_resource_r_fields(self, resource: Resource, port_name: str):
        """check all ResourceRField are resource that are input of the task
        """

        # get the ResourceRField of the resource
        r_fields: Dict[str, ResourceRField] = ReflectorHelper.get_property_names_of_type(
            type(resource), ResourceRField)

        for key, r_field in r_fields.items():
            # get the attribute value corresponding to the r_field
            r_field_value: Any = getattr(resource, key)

            # retrieve the resource model id
            resource_model_id = r_field.serialize(r_field_value)

            if not resource_model_id:
                continue

            # if the resource r field is not listed in task input, error
            if not self.inputs.has_resource_model(resource_model_id):
                raise BadRequestException(GWSException.INVALID_LINKED_RESOURCE.value,
                                          unique_code=GWSException.INVALID_LINKED_RESOURCE.name,

                                          detail_args={'port_name': port_name})

    def _get_input_resource_tags(self) -> List[Tag]:
        """Return all the tags of all the input resources
        """

        if self._input_resource_tags is None:
            tags: List[Tag] = []

            for input_resource in self.inputs.get_resource_models().values():
                entity_tags = EntityTagList.find_by_entity(EntityType.RESOURCE, input_resource.id)
                tags += entity_tags.build_tags_propagated(TagOriginType.TASK_PROPAGATED, self.id)

            self._input_resource_tags = tags

        return self._input_resource_tags

    def _get_scenario_tags(self) -> List[Tag]:
        """Return all the tags of the scenario
        """
        entity_tags = EntityTagList.find_by_entity(EntityType.SCENARIO, self.scenario.id)
        return entity_tags.build_tags_propagated(TagOriginType.SCENARIO_PROPAGATED, self.scenario.id)

    ################################# CONFIG #################################

    def set_config_value(self, param_name: str, value: Any) -> None:
        """Set a value of the config

        :param param_name: [description]
        :type param_name: str
        :param value: [description]
        :type value: Any
        """
        super().set_config_value(param_name, value)
        self._on_new_config()

    def set_config_values(self, config_values: ConfigParamsDict) -> None:
        """Set the config values

        :param config_values: [description]
        :type config_values: Dict[str, Any]
        """
        super().set_config_values(config_values)
        self._on_new_config()

    def set_config(self, config: Config) -> None:
        """Set the config

        :param config: [description]
        :type config: ConfigParamsDict
        """
        super().set_config(config)
        self._on_new_config()

    def _on_new_config(self) -> None:
        """Method called when the config of the task is changed to
        update the source_config_id if the task is a source task
        """

        if self.is_input_task():
            resource_model_id = InputTask.get_resource_id_from_config(
                self.config.get_values())

            if resource_model_id is not None:
                resource = ResourceModel.get_by_id(resource_model_id)

                if resource is not None:
                    self.source_config_id = resource.id
            else:
                self.source_config_id = None

    ################################# OTHER #################################

    def mark_as_started(self):
        if self.is_running:
            return
        self.progress_bar.start()
        self.progress_bar.add_message(
            f"Start of task '{self.get_instance_name_context()}'")
        self.status = ProcessStatus.RUNNING
        self.started_at = DateHelper.now_utc()
        self.save()

    def check_is_updatable(self, error_if_finished: bool = True) -> None:
        super().check_is_updatable(error_if_finished)

        if self.parent_protocol:
            self.parent_protocol.check_is_updatable(error_if_finished=error_if_finished)

    def to_dto(self):
        res = super().to_dto()
        res.community_agent_version_id = self.community_agent_version_id
        res.community_agent_version_modified = self.community_agent_version_modified
        return res

    def get_community_agent_version_id(self) -> str:
        return self.community_agent_version_id

    def get_community_agent_version_modified(self) -> bool:
        return self.community_agent_version_modified
