# LICENSE
# This software is the exclusive property of Gencovery SAS.
# The use and distribution of this software is prohibited without the prior consent of Gencovery SAS.
# About us: https://gencovery.com

from typing import Optional

from fastapi import Depends
from fastapi.responses import RedirectResponse
from starlette.responses import JSONResponse, Response

from gws_core.core.classes.jsonable import ListJsonable
from gws_core.core.service.front_service import FrontService
from gws_core.lab.dev_env_service import DevEnvService
from gws_core.user.current_user_service import CurrentUserService
from gws_core.user.jwt_service import JWTService
from gws_core.user.user import User, UserDataDict

from ..core_app import core_app
from ..user.auth_service import AuthService
from .user_credentials_dto import UserCredentials2Fa, UserCredentialsDTO
from .user_service import UserService


@core_app.get("/user/me", tags=["User"])
def read_user_me(_=Depends(AuthService.check_user_access_token)):
    """
    Get current user details.
    """

    return CurrentUserService.get_and_check_current_user().to_user_data_dict()


@core_app.get("/user/activity", tags=["User"], summary="Get user activities")
def get_user_activity(user_id: Optional[str] = None,
                      activity_type: Optional[str] = None,
                      page: int = 0,
                      number_of_items_per_page: int = 20,
                      _=Depends(AuthService.check_user_access_token)):
    """
    Get the list of user activities on the lab

    - **user_id**: the id the user [optional]
    - **activity_type**: the type of the activity to retrieve [optional]. The valid types of activities are:
      - **CREATE** : the creation of an object
      - **SAVE**   : the saving of an object
      - **START**  : the start of an experiment
      - **STOP**   : the stop of an experiment
      - **DELETE** : the deletion of an experiment
      - **ARCHIVE** : the archive of an object
      - **VALIDATE** : the valdaition of an experiment
      - **HTTP_AUTHENTICATION** : HTTP authentication
      - **HTTP_UNAUTHENTICATION** : HTTP unauthentication
      - **CONSOLE_AUTHENTICATION** : console authentication (through CLI or notebook)
      - **CONSOLE_UNAUTHENTICATION** : console unauthentication
    - **page**: the page number
    - **number_of_items_per_page**: the number of items per page. Defaults to 20 items per page.
    """

    return UserService.fecth_activity_list(
        user_id=user_id,
        activity_type=activity_type,
        page=page,
        number_of_items_per_page=number_of_items_per_page,
    ).to_json()


@core_app.post("/login", tags=["User"], summary="Login to the lab by requesting space")
def login(credentials: UserCredentialsDTO) -> JSONResponse:
    """
    Log the user using space
    """

    return AuthService.login(credentials)


@core_app.post("/login-2fa", tags=["User"], summary="Login 2FA to the lab by requesting space")
def login_2_fa(credentials: UserCredentials2Fa) -> JSONResponse:
    """
    Login 2FA to the lab by requesting space
    """

    return AuthService.login_with_2fa(credentials)


@core_app.get("/check-token", tags=["User"], summary="Check user's token")
def check_token(current_user: User = Depends(AuthService.check_user_access_token)) -> str:
    """Simple route to check the user's token (used in automatic dev login), returns the user's id if valid
    """
    return current_user.id


@core_app.get("/login-temp-access/{unique_code}", tags=["User"],
              summary="Log the user from the temp access token generated by space")
def login_from_temp_token(unique_code: str) -> Response:

    try:
        user: User = AuthService.check_unique_code(unique_code)

        response = RedirectResponse(FrontService.get_auto_login_url(JWTService.get_token_duration_in_seconds()))
        return AuthService.log_user(user, response=response)
    except Exception:
        # if there is any problem redirect to the front base url (login)
        return RedirectResponse(FrontService.get_front_url())


@core_app.post("/dev-login/{code}", tags=["User"], summary="Login to the dev lab using an unique code")
def dev_login(code: str) -> Response:
    """
    Log the user on the dev lab by calling the prod api, using a temp code generated by the prod api
    """

    return DevEnvService.dev_get_check_user(code)


@core_app.get("/dev-login-unique-code/generate", tags=["User"],
              summary="Generate a temp unique code to login to the dev lab")
def generate_dev_login_unique_code(current_user: User = Depends(AuthService.check_user_access_token)) -> str:
    """
    Generate a temp unique code to login to the dev lab
    """
    return DevEnvService.generate_dev_login_unique_code(current_user.id)


@core_app.post("/dev-login-unique-code/check/{unique_code}", tags=["User"],
               summary="Check the temp unique code to login to the dev lab")
def check_dev_login_unique_code(unique_code: str) -> UserDataDict:
    """
    Check the temp unique code to login to the dev lab
    """
    return DevEnvService.check_dev_login_unique_code(unique_code).to_user_data_dict()


@core_app.post("/logout", tags=["User"], summary="Logout the user")
def logout() -> JSONResponse:
    """
    Logout
    """

    return AuthService.logout()


@core_app.get("/user", tags=["User"])
def get_all_users(_=Depends(AuthService.check_user_access_token)):
    """
    List the users.
    """

    return ListJsonable(UserService.get_all_real_users()).to_json()


@core_app.post("/user/synchronize", tags=["User"])
def synchronize_users(_=Depends(AuthService.check_user_access_token)) -> None:
    """
    Synchronize the projects from space
    """

    return UserService.synchronize_all_space_users()


@core_app.get("/user/{id}", tags=["User"])
def get_by_id_and_check(id: str,
                        _=Depends(AuthService.check_user_access_token)) -> dict:
    return UserService.get_by_id_and_check(id).to_json()


@core_app.get("/user/name-search/{name}", tags=["User"])
def search_user_by_name(name: str,
                        page: int = 0,
                        number_of_items_per_page: int = 20,
                        _=Depends(AuthService.check_user_access_token)) -> dict:
    """
    Search users by name
    """
    return UserService.smart_search_by_name(name, page, number_of_items_per_page).to_json()
