# LICENSE
# This software is the exclusive property of Gencovery SAS.
# The use and distribution of this software is prohibited without the prior consent of Gencovery SAS.
# About us: https://gencovery.com


from typing import Any

from numpy import NaN

from gws_core.config.config_params import ConfigParams
from gws_core.config.config_types import ConfigSpecs
from gws_core.config.param.param_spec import StrParam
from gws_core.impl.table.helper.table_concat_helper import TableConcatHelper
from gws_core.impl.table.table import Table
from gws_core.io.dynamic_io import DynamicInputs
from gws_core.io.io_spec import InputSpec, OutputSpec
from gws_core.io.io_specs import InputSpecs, OutputSpecs
from gws_core.resource.resource_set.resource_list import ResourceList
from gws_core.task.task import Task
from gws_core.task.task_decorator import task_decorator
from gws_core.task.task_io import TaskInputs, TaskOutputs

fill_nan_param = StrParam(default_value='NaN',
                          human_name='Fill empty values with',
                          short_description='Fill empty value generated by the concat with this value',
                          allowed_values=['NaN', 'Empty', '0'])


def get_fill_nan_value(fill_nan_option: str) -> Any:
    if fill_nan_option == 'NaN':
        return NaN
    elif fill_nan_option == 'Empty':
        return None
    elif fill_nan_option == '0':
        return 0


@task_decorator(
    unique_name="TableRowConcat",
    short_description="Concatenate two tables along the rows by merging columns",
)
class TableRowConcat(Task):
    """
    Concatenate two tables along the rows by merging columns.
    The total number of rows will be the sum of the two tables. The total number of columns will depend if the two table
    have common columns (based on name).

    If the two table have the same column (based on name), the values of theses columns are concatenated (starting from the first table) into the same column.

    If a column doesn't exist in the other table, it will be concatenate with value provided in the ```Fill empty values with``` parameter.

    ## Example

    Let's say you have the following tables.

    | A          | B          |
    |------------|------------|
    | A1         | B1         |
    | A2         | B2         |

    | A          | C          |
    |------------|------------|
    | A3         | C3         |
    | A4         | C4         |

    Here is the result of the row concatenation.

    | A          | B          | C          |
    |------------|------------|------------|
    | A1         | B1         | NaN        |
    | A2         | B2         | NaN        |
    | A3         | NaN        | C3         |
    | A4         | NaN        | C4         |

    ```NaN``` value are create for the ```B``` and ```C``` columns because they don't exist in the other table. You can provide another value with the ```Fill empty values with``` parameter.

    The first two rows will have the tags from the first table and the last two rows will have the tags from the second.

    The column tags will depend on ```Column tags options``` parameter.

    ## Parameters
    ### Column tags options

    This parameter allows you to define what to do with the column tags. Here is the different options:
    - ```ignore```: the tags are ignored and left empty
    - ```keep first```: only the tags of the first table are keept
    - ```merge from first table```: tags of the first and second table are merged (the first table tags override the second table tags)
    """

    input_specs: InputSpecs = DynamicInputs({
        'table_1': InputSpec(Table, human_name='First table'),
        'table_2': InputSpec(Table, human_name='Second table'),
    }, additionnal_port_spec=InputSpec(Table, human_name='Table'))

    output_specs: OutputSpecs = OutputSpecs({
        'table': OutputSpec(Table, human_name='Concatenated table'),
    })

    config_specs: ConfigSpecs = {
        'column_tags_options': StrParam(human_name='Column tags options',
                                        short_description='What to do with the column tags. See doc for more info',
                                        allowed_values=TableConcatHelper.OPPOSITE_TAG_OPTIONS,
                                        default_value='ignore'),
        'fill_nan': fill_nan_param
    }

    def run(self, params: ConfigParams, inputs: TaskInputs) -> TaskOutputs:

        resource_list: ResourceList = inputs['source']
        fill_nan_value = get_fill_nan_value(params['fill_nan'])

        result = TableConcatHelper.concat_table_rows(resource_list.to_list(),
                                                     params['column_tags_options'],
                                                     fill_nan_value)

        return {'table': result}


@task_decorator(
    unique_name="TableColumnConcat",
    short_description="Concatenate two tables along the columns by merging rows",
)
class TableColumnConcat(Task):
    """
    Concatenate two tables along the columns by merging rows.
    The total number of columns will be the sum of the two tables. The total number of rows will depend if the two table
    have common rows (based on name).

    If the two table have the same row (based on name), the values of theses rows are concatenated (starting from the first table) into the same row.

    If a row doesn't exist in the other table, it will be concatenate with value provided in the ```Fill empty values with``` parameter.

    ## Example

    Let's say you have the following tables.

    | Row names | 1          | 2          |
    |-----------|------------|------------|
    | A         | A1         | A2         |
    | B         | B1         | B2         |

    | Row names | 3          | 4          |
    |---------- |------------|------------|
    | A         | A3         | A4         |
    | C         | C3         | C4         |

    Here is the result of the column concatenation.

    | Row names | 1          | 2          | 3          | 4          |
    |-----------|------------|------------|------------|------------|
    | A         | A1         | A2         | A3         | A4         |
    | B         | B1         | B2         | NaN        | NaN        |
    | C         | NaN        | NaN        | C3         | C4         |


    ```NaN``` value are create for the ```B``` and ```C``` rows because they don't exist in the other table. You can provide another value with the ```Fill empty values with``` parameter.

    The first two columns will have the tags from the first table and the last two columns will have the tags from the second.

    The row tags will depend on ```Row tags options``` parameter.

    ## Parameters
    ### Row tags options

    This parameter allows you to define what to do with the column tags. Here is the different options:
    - ```ignore```: the tags are ignored and left empty
    - ```keep first```: only the tags of the first table are keept
    - ```merge from first table```: tags of the first and second table are merged (the first table tags override the second table tags)
    """

    input_specs: InputSpecs = DynamicInputs({
        'table_1': InputSpec(Table, human_name='First table'),
        'table_2': InputSpec(Table, human_name='Second table'),
    }, additionnal_port_spec=InputSpec(Table, human_name='Table'))

    output_specs: OutputSpecs = OutputSpecs({
        'table': OutputSpec(Table, human_name='Concatenated table'),
    })

    config_specs: ConfigSpecs = {
        'row_tags_options': StrParam(human_name='Row tags options',
                                     short_description='What to do with the row tags. See doc for more info',
                                     allowed_values=TableConcatHelper.OPPOSITE_TAG_OPTIONS,
                                     default_value='ignore'),
        'fill_nan': fill_nan_param
    }

    def run(self, params: ConfigParams, inputs: TaskInputs) -> TaskOutputs:

        resource_list: ResourceList = inputs['source']
        fill_nan_value = get_fill_nan_value(params['fill_nan'])

        result = TableConcatHelper.concat_table_columns(resource_list.to_list(),
                                                        params['row_tags_options'],
                                                        fill_nan_value)

        return {'table': result}
